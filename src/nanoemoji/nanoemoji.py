# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Create an emoji font from a set of SVGs.

UFO handling informed by:
Cosimo's https://gist.github.com/anthrotype/2acbc67c75d6fa5833789ec01366a517
Notes for https://github.com/googlefonts/ufo2ft/pull/359

For COLR:
    Each SVG file represent one base glyph in the COLR font.
    For each glyph, we get a sequence of PaintedLayer.
    To convert to font format we  use the UFO Glyph pen.

Sample usage:
nanoemoji -v 1 $(find ~/oss/noto-emoji/svg -name '*.svg')
nanoemoji $(find ~/oss/twemoji/assets/svg -name '*.svg')
"""
from absl import app
from absl import flags
from absl import logging
import glob
from nanoemoji import config
from nanoemoji.config import AxisPosition, FontConfig, MasterConfig
from nanoemoji import write_font
from ninja import ninja_syntax
import os
from pathlib import Path
import subprocess
import sys
from typing import NamedTuple, Tuple, Sequence


FLAGS = flags.FLAGS


# internal flags, typically client wouldn't change
flags.DEFINE_string("build_dir", "build/", "Where build runs.")
flags.DEFINE_bool("gen_ninja", True, "Whether to regenerate build.ninja")
flags.DEFINE_bool("exec_ninja", True, "Whether to run ninja.")


def self_dir() -> Path:
    return Path(__file__).parent.resolve()


def build_dir() -> Path:
    return Path(FLAGS.build_dir).resolve()


def rel(from_path: Path, to_path: Path) -> Path:
    # relative_to(A,B) doesn't like it if B doesn't start with A
    return Path(os.path.relpath(str(to_path.resolve()), str(from_path.resolve())))


def rel_self(path: Path) -> Path:
    return rel(self_dir(), path)


def rel_build(path: Path) -> Path:
    return rel(build_dir(), path)


def write_preamble(nw):
    def module_rule(mod_name, arg_pattern):
        nw.rule(mod_name, f"{sys.executable} -m nanoemoji.{mod_name} {arg_pattern}")

    nw.comment("Generated by nanoemoji")
    nw.newline()

    nw.rule("picosvg", 'picosvg $in > $out || echo "$in failed picosvg"')
    module_rule("write_codepoints", "$in > $out")
    module_rule("write_fea", "$in > $out")

    keep_glyph_names = " --"
    if not FLAGS.keep_glyph_names:
        keep_glyph_names += "no"
    keep_glyph_names += "keep_glyph_names"
    module_rule(
        "write_font",
        f" --upem {FLAGS.upem}"
        + f' --family "{FLAGS.family}"'
        + f" --color_format {FLAGS.color_format}"
        + f" --output {FLAGS.output}"
        + keep_glyph_names
        + " --output_file $out $in",
    )
    nw.newline()

    module_rule(
        "write_variable_font", f"--config {rel_build(Path(FLAGS.config).resolve())} $in"
    )


def picosvg_dest(master_name: str, svg: Path) -> str:
    return os.path.join("picosvg", master_name, svg.name)


def write_picosvg_builds(nw: ninja_syntax.Writer, master: MasterConfig):
    os.makedirs(str(build_dir() / "picosvg" / master.name), exist_ok=True)
    for svg_file in master.sources:
        nw.build(
            picosvg_dest(master.name, svg_file), "picosvg", str(rel_build(svg_file))
        )
    nw.newline()


def write_source_names(source_names: Sequence[str]):
    with open(os.path.join(build_dir(), "source_names.txt"), "w") as f:
        for source_name in source_names:
            f.write(source_name)
            f.write("\n")


def write_codepointmap_build(nw: ninja_syntax.Writer):
    dest_file = "codepointmap.csv"
    nw.build(dest_file, "write_codepoints", ["source_names.txt"])
    nw.newline()


def write_fea_build(nw: ninja_syntax.Writer):
    nw.build("features.fea", "write_fea", "codepointmap.csv")
    nw.newline()


def write_ufo_build(nw: ninja_syntax.Writer, master: MasterConfig):
    inputs = ["codepointmap.csv", "features.fea"] + [
        picosvg_dest(master.name, s) for s in master.sources
    ]
    nw.build(
        master.output_ufo, "write_font", inputs,
    )
    nw.newline()


def write_static_font_build(nw: ninja_syntax.Writer, font_config: FontConfig):
    master = font_config.masters[0]
    inputs = ["codepointmap.csv", "features.fea"] + [
        picosvg_dest(master.name, s) for s in master.sources
    ]
    nw.build(
        font_config.output_file, "write_font", inputs,
    )
    nw.newline()


def write_variable_font_build(nw: ninja_syntax.Writer, font_config: FontConfig):
    inputs = [m.output_ufo for m in font_config.masters]
    nw.build(
        font_config.output_file, "write_variable_font", inputs,
    )
    nw.newline()


def _run(argv):

    font_config = config.load()

    is_vf = len(font_config.masters) > 1
    is_svg = font_config.color_format.endswith(
        "svg"
    ) or font_config.color_format.endswith("svgz")
    if is_vf and is_svg:
        raise ValueError("svg formats cannot have multiple masters")

    os.makedirs(build_dir(), exist_ok=True)
    build_file = build_dir() / "build.ninja"
    if FLAGS.gen_ninja:
        print(f"Generating {build_file.relative_to(build_dir())}")
        write_source_names(font_config.source_names)
        with open(build_file, "w") as f:
            nw = ninja_syntax.Writer(f)
            write_preamble(nw)

            write_codepointmap_build(nw)
            write_fea_build(nw)

            for master in font_config.masters:
                write_picosvg_builds(nw, master)
                if is_vf:
                    write_ufo_build(nw, master)

            if is_vf:
                write_variable_font_build(nw, font_config)
            else:
                write_static_font_build(nw, font_config)

    ninja_cmd = ["ninja", "-C", os.path.dirname(build_file)]
    if FLAGS.exec_ninja:
        print(" ".join(ninja_cmd))
        subprocess.run(ninja_cmd, check=True)
    else:
        print("To run:", " ".join(ninja_cmd))

    return


def main():
    # We don't seem to be __main__ when run as cli tool installed by setuptools
    app.run(_run)


if __name__ == "__main__":
    app.run(_run)
